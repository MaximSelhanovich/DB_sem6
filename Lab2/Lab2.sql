drop table Students_logs; /
DROP TABLE Groups_logs; /
DROP TABLE Students; /
DROP TABLE Groups; /

CREATE TABLE Groups 
(
    id NUMBER GENERATED ALWAYS as IDENTITY(START with 1 INCREMENT by 1) NOT NULL PRIMARY KEY,
    name VARCHAR2(200) NOT NULL,
    c_val NUMBER DEFAULT 0
); /

CREATE TABLE Students
(
    id NUMBER GENERATED ALWAYS as IDENTITY(START with 1 INCREMENT by 1) NOT NULL PRIMARY KEY,
    name VARCHAR2(200) NOT NULL,
    group_id NUMBER NOT NULL,
    CONSTRAINT fk_group_id
        FOREIGN KEY (group_id)
        REFERENCES Groups(id)
); /

CREATE TABLE Students_logs
(
    id NUMBER GENERATED ALWAYS as IDENTITY(START with 1 INCREMENT by 1) NOT NULL PRIMARY KEY,
    who_changed VARCHAR2(100),
    when_changed TIMESTAMP,
    operation_type VARCHAR2(1),
    student_id NUMBER NOT NULL,
    name VARCHAR2(200) NOT NULL,
    group_id NUMBER NOT NULL
); /

CREATE TABLE Groups_logs
(
    id NUMBER GENERATED ALWAYS as IDENTITY(START with 1 INCREMENT by 1) NOT NULL PRIMARY KEY,
    who_changed VARCHAR2(100),
    when_changed TIMESTAMP,
    operation_type VARCHAR2(1),
    group_id NUMBER NOT NULL,
    name VARCHAR2(200) NOT NULL
);


CREATE OR REPLACE TRIGGER cascade_students_delete
BEFORE DELETE 
ON Groups
FOR EACH ROW
BEGIN
    DELETE FROM students WHERE students.group_id = :OLD.id;
END cascade_students_delete; /



CREATE OR REPLACE TRIGGER num_students_update
BEFORE DELETE OR INSERT
ON Students
FOR EACH ROW
DECLARE
    PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
    CASE
        WHEN INSERTING THEN
            UPDATE Groups SET groups.c_val = groups.c_val + 1 
            WHERE groups.id = :NEW.group_id;
        WHEN DELETING THEN
            UPDATE Groups SET groups.c_val = groups.c_val - 1
            WHERE groups.id = :OLD.group_id;
        END CASE;
    COMMIT;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        dbms_output.put_line(SQLERRM);
END num_students_update; /

CREATE OR REPLACE TRIGGER group_name_check
BEFORE 
    INSERT OR 
    UPDATE OF name
ON Groups
FOR EACH ROW
DECLARE
    unique_check NUMBER;
    NOT_UNIQUE_GROUP_NAME EXCEPTION;
BEGIN
    SELECT COUNT(*) INTO unique_check from Groups WHERE name = :NEW.name;
    IF unique_check > 0 THEN
        RAISE NOT_UNIQUE_GROUP_NAME;
    END IF;
END group_name_check; /

CREATE OR REPLACE TRIGGER log_students_changes
AFTER INSERT OR UPDATE OR DELETE
ON Students
FOR EACH ROW
DECLARE
    op_type varchar2(1) :=
        CASE WHEN UPDATING THEN 'U'
             WHEN DELETING THEN 'D'
             ELSE 'I' END;
BEGIN
    IF UPDATING OR INSERTING THEN
        INSERT INTO Students_logs VALUES
        (DEFAULT, USER, SYSDATE(), op_type, :NEW.id, :NEW.name, :NEW.group_id);
    ELSE
        INSERT INTO Students_logs VALUES
        (DEFAULT, USER, SYSDATE(), op_type, :OLD.id, :OLD.name, :OLD.group_id);    
    END IF;
END log_students_changes; /

CREATE OR REPLACE TRIGGER log_groups_changes
AFTER INSERT OR 
UPDATE OF name
OR DELETE
ON Groups
FOR EACH ROW
DECLARE
    op_type varchar2(1) :=
        CASE WHEN UPDATING THEN 'U'
             WHEN DELETING THEN 'D'
             ELSE 'I' END;
BEGIN
    IF UPDATING OR INSERTING THEN
        INSERT INTO Groups_logs VALUES
        (DEFAULT, USER, SYSDATE(), op_type, :NEW.id, :NEW.name);
    ELSE
        INSERT INTO Groups_logs VALUES
        (DEFAULT, USER, SYSDATE(), op_type, :OLD.id, :OLD.name);    
    END IF;
END log_groups_changes; /

BEGIN
    EXECUTE IMMEDIATE 'ALTER TABLE Groups DISABLE ALL TRIGGERS';
    EXECUTE IMMEDIATE 'ALTER TABLE Groups ENABLE ALL TRIGGERS'; 
END;
CREATE OR REPLACE PROCEDURE default_group_restore(restore_group_id NUMBER, time_to_go_back TIMESTAMP) IS
    new_id number(10) := 0;    
BEGIN
    EXECUTE IMMEDIATE 'ALTER TABLE Groups DISABLE ALL TRIGGERS';
    EXECUTE IMMEDIATE 'TRUNCATE TABLE Groups';
    EXECUTE IMMEDIATE 'ALTER TABLE Groups MODIFY id generated by default as identity';
    
    FOR REC IN (SELECT operation_type, group_id, name FROM Groups_logs WHERE when_changed <= time_to_go_back)
    LOOP
        IF REC.operation_type = 'I' THEN
            INSERT INTO Groups(id, name) VALUES(REC.group_id, REC.NAME);
        ELSIF REC.operation_type = 'D' THEN
            DELETE FROM Groups WHERE ID = REC.group_id;
        ELSE 
            UPDATE Groups SET name = REC.NAME WHERE ID = REC.group_id;
        END IF;
    END LOOP;
    
    SELECT NVL(MAX(ID), 0) + 1 INTO new_id FROM Groups; 
    EXECUTE IMMEDIATE 'alter table Groups modify id generated always as identity(START with ' || new_id || ' INCREMENT by 1)';
    EXECUTE IMMEDIATE 'ALTER TABLE Groups ENABLE ALL TRIGGERS';    
END default_group_restore;

CREATE OR REPLACE PROCEDURE go_back(time_to_go_back TIMESTAMP) IS
    new_id number(10) := 0;
    GROUP_CHECK NUMBER(1);
BEGIN
    EXECUTE IMMEDIATE 'ALTER TABLE Students DISABLE ALL TRIGGERS';
    EXECUTE IMMEDIATE 'ALTER TRIGGER num_students_update ENABLE';
    EXECUTE IMMEDIATE 'TRUNCATE TABLE Students';
    EXECUTE IMMEDIATE 'ALTER TABLE Students MODIFY id generated by default as identity';
    
    FOR REC IN (SELECT operation_type, student_id, name, group_id FROM Students_logs WHERE when_changed <= time_to_go_back)
    LOOP
        IF REC.student_id > new_id THEN
            new_id := REC.student_id;
        END IF;
        
        IF REC.operation_type = 'I' THEN
            SELECT COUNT(*) INTO GROUP_CHECK FROM Groups WHERE ID = REC.GROUP_ID;
            IF GROUP_CHECK = 0 THEN
                default_group_restore(REC.GROUP_ID, time_to_go_back);
            END IF;
        
            INSERT INTO Students VALUES(REC.student_id, REC.NAME, REC.GROUP_ID);
        ELSIF REC.operation_type = 'D' THEN
            DELETE FROM Students WHERE ID = REC.student_id;
        ELSE 
            UPDATE Students SET name = REC.NAME, GROUP_ID = REC.GROUP_ID WHERE ID = REC.student_id;
        END IF;
    END LOOP;
    
    new_id := new_id+1; 
    EXECUTE IMMEDIATE 'alter table Students modify id generated always as identity(START with ' || new_id || ' INCREMENT by 1)';
    EXECUTE IMMEDIATE 'ALTER TABLE Students ENABLE ALL TRIGGERS';
END go_back; /

CREATE OR REPLACE PROCEDURE go_back_interval(minutes_to_go_back NUMBER) is
BEGIN
    go_back(SYSDATE() - (1 / 1440 * minutes_to_go_back));
END go_back_interval;


insert into Groups(name) values('yes'); /
insert into Groups(name) values('NO'); /
insert into Groups(name) values('Maybe'); /
commit; /
select * from Groups;

insert into Groups(name) values('Maybe');
insert into groups(id, name) values(6, 'Nein');

insert into students(ID, name, group_id) values(3, 'dUFFI', 3);

insert into students(name, group_id) values('Me', 1); /
insert into students(name, group_id) values('another', 1); /
insert into students(name, group_id) values('Mario', 2); /
insert into students(name, group_id) values('sONIC', 2); /
insert into students(name, group_id) values('Duck', 3); /
select * from Groups; /
commit;

update  students set name = 'gfdhtdytrc' where id = 1; /
SELECT * FROM Students_logs;

SELECT * FROM groups; /
DELETE FROM students WHERE students.NAME = 'sONIC'; /
DELETE FROM students WHERE students.ID = 3;
commit;

DELETE FROM groups WHERE NAME = 'NO'; /
SELECT * FROM STUDENTS;
SELECT * FROM groups;

SELECT * FROM Students_logs;
SELECT * FROM groups_logs;
SELECT operation_type, group_id, name FROM Groups_logs WHERE group_id = 2;
begin
    go_back(TO_TIMESTAMP('13-FEB-23 08.17.13.000000000 PM'));
end;
TRUNCATE TABLE Students;
TRUNCATE TABLE groups;
/*ALTER TABLE students ENABLE ROW MOVEMENT;
flashback table students to timestamp (SYSTIMESTAMP - INTERVAL '1' hour);*/